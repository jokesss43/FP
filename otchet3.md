## 1. Введение и цель проекта

Разработана многопоточная система симуляции работы магазина, демонстрирующая взаимодействие двух типов агентов (покупателей и кассиров) через ограниченную очередь товаров. Основная цель проекта - практическое применение функционального программирования, асинхронных вычислений и ленивых коллекций Scala для решения задач конкурентного программирования.

## 2. Архитектурные решения

### 2.1. Основные сущности системы

Система построена вокруг трех ключевых компонентов:

**ShopQueue** - потокобезопасная очередь с фиксированной емкостью, обеспечивающая синхронизированный доступ для производителей (покупателей) и потребителей (кассиров). Реализация использует комбинацию ConcurrentLinkedQueue для хранения элементов и AtomicInteger для атомарного отслеживания размера.

**Product** - простейшая модель товара, содержащая идентификатор и информацию для демонстрации.

**Simulation Controller** - центральный координатор, управляющий жизненным циклом симуляции, сбором статистики и остановкой по таймеру.

### 2.2. Параллельная архитектура

Система реализует классический паттерн Producer-Consumer с модификациями:

- **Несколько производителей** (покупатели) независимо добавляют товары
- **Несколько потребителей** (кассиры) параллельно обрабатывают товары
- **Единая ограниченная очередь** как механизм синхронизации
- **Детектор переполнения** для обработки случаев, когда очередь достигла максимального размера

## 3. Функциональные особенности реализации

### 3.1. Вычисления с LazyList

**Ленивое создание асинхронных задач** - вместо немедленного создания всех Future для покупателей и кассиров, система генерирует их по требованию. Это обеспечивает масштабируемость при большом количестве участников.

**Функциональная реализация главного меню** - бесконечный интерактивный цикл реализован через трансформацию ленивой последовательности, что исключает риски переполнения стека

### 3.2. Асинхронная обработка с Future

Каждая задача покупателя и кассира выполняется в отдельной асинхронной обертке Future, что позволяет:

- Эмулировать реальное параллельное выполнение
- Управлять задержками независимо для каждого агента
- Легко масштабировать количество участников

### 3.3. Управление временем и остановкой

Симуляция использует два механизма контроля времени:

**Таймер выполнения** - задается пользователем и гарантирует остановку через указанный интервал

**Promise-сигнал остановки** - общий сигнал для всех потоков о необходимости завершения работы

Комбинация этих механизмов обеспечивает корректное завершение всех потоков без утечек ресурсов.

## 4. Пользовательский интерфейс

### 4.1. Интерактивная настройка параметров

Система предоставляет пошаговый интерфейс для настройки всех параметров симуляции:

- **Время работы** магазина (от 1 до 300 секунд)
- **Количество кассиров** (от 1 до 20)
- **Количество покупателей** (от 1 до 50)
- **Максимальный размер очереди** (от 1 до 100)

Каждый параметр валидируется с понятными сообщениями об ошибках и значениями по умолчанию.

### 4.2. Циклическое выполнение с сохранением состояния

Пользователь может последовательно запускать несколько симуляций с разными параметрами, что полезно для сравнительного анализа. После каждой симуляции система предлагает продолжить или завершить работу.

## 5. Статистика и мониторинг

### 5.1. Сбор метрик в реальном времени

В процессе выполнения отслеживаются:

- Общее количество добавленных товаров
- Количество успешно обработанных товаров
- Число отказов при добавлении (очередь полна)
- Текущий размер очереди

### 5.2. Итоговый отчет

По завершении симуляции формируется сводный отчет, включающий:

- Все входные параметры
- Собранную статистику производительности
- Состояние очереди на момент завершения
- Индикаторы эффективности работы системы

Пример отчета выглядит так:

'''
Симуляция завершена
Товаров добавлено: 12
Товаров обработано: 7
Отказов в добавлении: 5
Товаров осталось в очереди: 5
'''


## 6. Обработка ошибок и устойчивость

### 6.1. Валидация пользовательского ввода

Система защищена от некорректных входных данных через:

- Проверку диапазонов значений
- Обработку нечислового ввода
- Предоставление безопасных значений по умолчанию

### 6.2. Управление исключениями в параллельных потоках

Асинхронные задачи обернуты в механизмы обработки исключений, предотвращающие аварийное завершение всей системы при сбое в отдельном потоке.

## 7. Производительность и оптимизации

### 7.1. Эффективное использование памяти

Ленивая генерация задач предотвращает создание ненужных объектов, что критично при большом количестве участников. Атомарные счетчики минимизируют блокировки между потоками.

### 7.2. Масштабируемость

Архитектура поддерживает конфигурации от минимальных (1 кассир, 1 покупатель) до достаточно крупных (20 кассиров, 50 покупателей) без структурных изменений.

### 7.3. Балансировка нагрузки

Случайные задержки в работе агентов (100-600 мс для покупателей, 200-1000 мс для кассиров) создают реалистичную нагрузку и предотвращают синхронные всплески активности.

## 8. Заключение

Разработанная система успешно демонстрирует принципы функционального и конкурентного программирования на языке Scala. Через относительно простую предметную область (работа магазина) показаны сложные технические концепции: ленивые вычисления, асинхронная обработка, синхронизация потоков, управление общими ресурсами.

Проект сочетает теоретическую ценность (демонстрация парадигм программирования) с практической полезностью (инструмент для экспериментов с системами массового обслуживания). Модульная архитектура и чистая реализация делают код легко расширяемым для более сложных сценариев.

Симуляция может быть полезна как для образовательных целей при изучении Scala и многопоточности, так и в качестве основы для более специализированных симуляционных систем в области исследования операций, анализа производительности и проектирования систем реального времени.